# 单元测试编写指南

本文档总结了模块单元测试的通用编写过程，适用于类似的插件/模块开发项目。

## 1. 测试框架配置

### 基本依赖
```json
{
  "devDependencies": {
    "mocha": "^11.7.5",
    "chai": "^6.2.2",
    "nyc": "^17.1.0"
  },
  "scripts": {
    "test": "mocha test/**/*.test.js",
    "test:coverage": "nyc --reporter=html --reporter=text mocha test/**/*.test.js"
  }
}
```

### 测试文件结构
```
test/
└── index.test.js
```

## 2. 测试结构设计

### 顶层 describe
使用模块名称作为最外层的 describe：
```javascript
describe('@kne/module-name', function() {
  // 所有测试用例
});
```

### 分类测试套件
根据功能模块创建嵌套的 describe，每个 describe 专注于一个功能点：

```javascript
describe('插件注册测试', () => {
  // 插件注册相关测试
});

describe('核心功能测试', () => {
  // 核心功能相关测试
});

describe('边界情况测试', () => {
  // 边界情况相关测试
});
```

## 3. 测试用例编写原则

### 3.1 基本测试模式
每个测试用例遵循 AAA 模式（Arrange-Act-Assert）：

```javascript
it('should do something when given condition', async () => {
  // Arrange - 准备测试数据和依赖
  const fastify = require('fastify')();
  
  // Act - 执行被测试的操作
  await fastify.register(yourPlugin, options);
  await fastify.ready();
  
  // Assert - 验证结果
  expect(fastify.decorator).to.exist;
  
  // Cleanup - 清理资源
  await fastify.close();
});
```

### 3.2 测试用例命名规范
- 使用 "should" 开头描述期望行为
- 格式：`should [action] when [condition]`
- 示例：
  - `should add decorator to fastify instance`
  - should fallback to default locale when no locale specified`
  - `should reject language not in whitelist`

## 4. 测试覆盖维度

### 4.1 插件注册测试
- 默认选项注册
- 自定义选项注册
- 装饰器添加验证

```javascript
describe('插件注册测试', () => {
  it('should add decorator with default options', async () => {
    const fastify = require('fastify')();
    await fastify.register(yourPlugin);
    await fastify.ready();
    expect(fastify.decorator).to.exist;
    await fastify.close();
  });

  it('should use custom options', async () => {
    const fastify = require('fastify')();
    await fastify.register(yourPlugin, {
      customOption: 'value'
    });
    await fastify.ready();
    expect(fastify.decorator).to.exist;
    await fastify.close();
  });
});
```

### 4.2 功能行为测试
- 基本功能验证
- 选项配置验证
- 数据处理验证

```javascript
describe('功能行为测试', () => {
  it('should process data correctly', async () => {
    const fastify = require('fastify')();
    const testData = { key: 'value' };
    
    await fastify.register(yourPlugin, {
      data: testData
    });
    await fastify.ready();
    
    const result = fastify.decorator.process();
    expect(result).to.equal('expected value');
    
    await fastify.close();
  });
});
```

### 4.3 优先级和顺序测试
验证参数获取的优先级顺序：

```javascript
describe('参数优先级测试', () => {
  it('should get from highest priority source', async () => {
    // 测试最高优先级来源
  });

  it('should fallback to lower priority', async () => {
    // 测试降级逻辑
  });

  it('should use default when no source available', async () => {
    // 测试默认值
  });
});
```

### 4.4 过滤和验证测试
验证白名单、黑名单等过滤逻辑：

```javascript
describe('过滤逻辑测试', () => {
  it('should accept value in whitelist', async () => {
    const fastify = require('fastify')();
    await fastify.register(yourPlugin, {
      whitelist: 'a,b,c'
    });
    await fastify.ready();
    
    const result = fastify.decorator.filter('a');
    expect(result).to.be.true;
    
    await fastify.close();
  });

  it('should reject value not in whitelist', async () => {
    const fastify = require('fastify')();
    await fastify.register(yourPlugin, {
      whitelist: 'a,b,c'
    });
    await fastify.ready();
    
    const result = fastify.decorator.filter('d');
    expect(result).to.be.false;
    
    await fastify.close();
  });
});
```

### 4.5 动态加载测试
验证异步数据加载和缓存：

```javascript
describe('动态加载测试', () => {
  it('should load data remotely and cache', async () => {
    const fastify = require('fastify')();
    let callCount = 0;
    
    const loader = async () => {
      callCount++;
      return { data: 'loaded' };
    };
    
    await fastify.register(yourPlugin, { loader });
    await fastify.ready();
    
    // 第一次调用触发加载
    await fastify.decorator.load();
    expect(callCount).to.equal(1);
    
    // 第二次调用使用缓存
    await fastify.decorator.load();
    expect(callCount).to.equal(1);
    
    await fastify.close();
  });
});
```

### 4.6 缓存机制测试
验证缓存的有效性和隔离性：

```javascript
describe('缓存机制测试', () => {
  it('should cache instances', async () => {
    const fastify = require('fastify')();
    await fastify.register(yourPlugin);
    await fastify.ready();
    
    const instance1 = fastify.decorator.create('key1');
    const instance2 = fastify.decorator.create('key1');
    
    expect(instance1).to.equal(instance2);
    
    await fastify.close();
  });

  it('should return different instances for different keys', async () => {
    const fastify = require('fastify')();
    await fastify.register(yourPlugin);
    await fastify.ready();
    
    const instance1 = fastify.decorator.create('key1');
    const instance2 = fastify.decorator.create('key2');
    
    expect(instance1).to.not.equal(instance2);
    
    await fastify.close();
  });
});
```

### 4.7 边界情况测试
测试异常输入、空值、极限值等：

```javascript
describe('边界情况测试', () => {
  it('should handle null input gracefully', async () => {
    const fastify = require('fastify')();
    await fastify.register(yourPlugin);
    await fastify.ready();
    
    expect(() => fastify.decorator.process(null)).to.not.throw();
    
    await fastify.close();
  });

  it('should handle empty object', async () => {
    const fastify = require('fastify')();
    await fastify.register(yourPlugin);
    await fastify.ready();
    
    const result = fastify.decorator.process({});
    expect(result).to.deep.equal({});
    
    await fastify.close();
  });
});
```

## 5. 断言最佳实践

### 5.1 使用语义化断言
```javascript
// 优先使用语义化断言
expect(value).to.exist;
expect(value).to.be.true;
expect(value).to.be.false;

// 而不是
expect(value !== undefined).to.be.true;
expect(value === true).to.be.true;
```

### 5.2 对象比较
```javascript
// 使用 deep.equal 进行对象比较
expect(result).to.deep.equal(expected);

// 或者比较特定属性
expect(result.property).to.equal(expectedValue);
```

### 5.3 异步断言
```javascript
it('should handle async operation', async () => {
  const fastify = require('fastify')();
  await fastify.register(yourPlugin);
  await fastify.ready();
  
  const result = await fastify.decorator.asyncMethod();
  expect(result).to.equal('expected');
  
  await fastify.close();
});
```

## 6. 测试数据管理

### 6.1 测试数据准备
```javascript
describe('测试场景', () => {
  const testData = {
    valid: { key: 'value' },
    invalid: {},
    edge: null
  };

  it('should handle valid data', async () => {
    // 使用 testData.valid
  });
});
```

### 6.2 Mock 外部依赖
```javascript
describe('外部依赖测试', () => {
  it('should handle external service', async () => {
    let mockCallCount = 0;
    const mockService = async () => {
      mockCallCount++;
      return { data: 'mocked' };
    };
    
    await fastify.register(yourPlugin, {
      service: mockService
    });
    await fastify.ready();
    
    // 验证调用次数和结果
    expect(mockCallCount).to.equal(1);
  });
});
```

## 7. 资源清理

### 7.1 必须清理资源
每个测试用例结束时都要清理创建的实例：

```javascript
it('test case', async () => {
  const fastify = require('fastify')();
  
  // ... 测试代码 ...
  
  await fastify.close(); // 必须调用
});
```

### 7.2 使用钩子进行清理
```javascript
describe('测试套件', () => {
  let fastify;
  
  beforeEach(async () => {
    fastify = require('fastify')();
    await fastify.register(yourPlugin);
    await fastify.ready();
  });
  
  afterEach(async () => {
    await fastify.close();
  });
  
  it('test 1', async () => {
    // 使用已初始化的 fastify
  });
  
  it('test 2', async () => {
    // 使用已初始化的 fastify
  });
});
```

## 8. 测试覆盖目标

- **函数覆盖率**：每个函数至少被调用一次
- **分支覆盖率**：每个条件分支都有测试
- **语句覆盖率**：每行可执行代码都被执行
- **边界覆盖**：测试最小值、最大值、空值、null 等

## 9. 运行测试

```bash
# 运行所有测试
npm test

# 运行测试并生成覆盖率报告
npm run test:coverage
```

## 10. 注意事项

1. **独立性**：每个测试用例应该独立运行，不依赖其他测试
2. **可重复性**：测试结果应该一致，不受环境或时间影响
3. **快速执行**：测试应该快速完成，避免不必要的延迟
4. **清晰命名**：测试用例名称应该清晰描述测试意图
5. **及时清理**：确保资源被正确释放，避免内存泄漏
